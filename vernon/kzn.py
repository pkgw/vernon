# -*- mode: python; coding: utf-8 -*-
# Copyright 2018 Peter Williams
# Licensed under the MIT License

"""Utility module for reading and working with the data files generated by the
Keller/Zwingmann/Neukirch code. Initial version largely transcribed from the
IDL code `fieldlines.pro` provided by Neukirch.

The finite element grid looks like this, more or less:

+---+
|  /|
| / |
|/  |
+---+
|  /|
| / |
|/  |
+---+

The "x" direction is radius, measured in the size of the central body, and the
"y" direction is colatitude theta, measured in radians. Viewing the grid as
squares, it is defined to be k_x squares wide and k_y squares tall. There are
`m = 2 k_x k_y` finite elements in total.

Each triangle has six node points: its three corners, and the three midpoints
of each of its sides. There are therefore `ip = (2 k_x + 1) (2 k_y + 1)`
control points in total.

The `m` finite elements and `ip` control points can be identified with an
index number into various arrays. We index these starting at 0, although the
FORTRAN code of course uses 1-based indexing. The `ind` array maps a finite
element number to the six control point numbers that define its shape. For
even-numbered finite elements (including the zero'th one), the ordering of the
six control points is as follows:


1--4--2
|    /
|   /
3  5
| /
|/
0

We call this an "upper-left" (UL) element. For odd-numbered elements, the
control points are mirror around the hypoteneuse:

      2
     /|
    / |
   5  4
  /   |
 /    |
0--3--1

These are "lower-right" (LR) elements. The 0'th and 1st elements are located
at the grid square at minimal X and Y; this is the bottom left of the grid in
the usual labeling. The 2nd and 3rd elements are located at the next higher X
value (i.e., to the right), up until the maximal X value. The (2k_x)th and
(2k_X + 1)th elements are at minimal X and almost-minimal Y; and so on.

Within each cell the "natural" triangular coordinate system is used. People
disagree on what this is, though! The code below calculates three coordinates,
(l0, l1, l2) or sometimes (dl0, dl1, dl2), subject to the constraint that
``l0 + l1 + l2 = 1``. This coordinate system is essentially rectangular:

- The l0 coordinate is 0 at the #1 control point and scales linearly to 1 at the
  #0 control point. In a UL element, l0 is essentially a negated Y coordinate.
  In a LR element, it is a negated X coordinate. (Recall that here "X" measures
  radius and "Y" measures colatitude.)

- The l2 coordinate is 0 at the #1 control point and scales linearly to 1 at
  the #2 control point. In a UL element it is an X coordinate, and in a BR
  element it is a Y coordinate.

- The l1 coordinate is then just ``1 - l0 - l2`` by definition.

When converting between physical coordinates and l0/l1/l2, don't forget that
different elements have different sizes because the mesh is nonuniform.

The numerical code solves for the magnetic flux function A (see near Eqn 9 of
the Neukirch paper). The actual magnetic field is then defined as

  B = grad(A) × grad(phi)

where, as far as I can convince myself, phi is the azimuthal coordinate. From
the definition of the gradient and cross product in spherical coordinates, we get:

  B_r     =  d(A)/d(colat) / (r^2 sin(colat))
  B_colat = -d(A)/dr / (r sin(colat))
  B_phi   = 0

If you load up the first dump from a simulation run, you can compare the
numerical values to analytical ones for a dipole:

  B_r     = 2 B0 r^3 cos(colat)
  B_colat = B0 r^3 sin(colat)
  B_phi   = 0

They should agree since the simulation starts with an unperturbed dipole.

"""
from __future__ import absolute_import, division, print_function

__all__ = '''
KZNField
KZNFieldConfiguration
KZNKWKDistribution
KZNModel
KZNModelConfiguration
'''.split()

import numpy as np
from pwkit import astutil
from pwkit.io import Path
from pwkit.numutil import broadcastize

from .bases import Distribution
from .config import Configuration


def parse_fortran_float(text):
    return float(text.replace('D', 'e'))


class KZNModelConfiguration(Configuration):
    __section__ = 'kzn-model'

    path = 'unset'
    "The path to the KZN text output file."

    soln_number = 0
    "Which solution iteration to load from the file (0-based)."

    def to_model(self):
        p = Path(self.path)
        if p != p.absolute():
            raise Exception('the \"path\" item of the kzn-model configuration '
                            'must be an absolute path')

        return KZNModel(
            self.path,
            self.soln_number,
        )


class KZNModel(object):
    "Data loaded from the Keller/Zwingmann/Neukirch numerical model."

    eta1 = None
    "The \"eta1\" parameter of the underlying simulation."

    eta3 = None
    "The \"eta3\" parameter of the underlying simulation."

    nu = None
    "The \"nu\" parameter of the underlying simulation."

    r_cutoff = None
    "The radius beyond which the density is forced to zero."

    ip = None
    "Number of control points."

    ind = None
    "Indices mapping FEM elements to control points."

    x = None
    "'X' coordinates (really radius) of control points."

    y = None
    "'Y' coordinates (really colatitude in radians) of control points."

    lam = None
    "The lambda value associated with the solution being used."

    uA = None
    "The FEM-discretized solution for the magnetic flux function A."

    def __init__(self, path, soln_number):
        with open(path, 'rt') as output:
            def _skip_to_section(secname, eof_ok=False):
                "Returns True if EOF was hit and eof_ok is True. False otherwise."

                while True:
                    line = output.readline()

                    if not len(line):
                        if eof_ok:
                            return True
                        raise Exception(f'hit EOF before finding section @{secname}')

                    pieces = line.rstrip().split(None, 1)
                    if not len(pieces):
                        continue

                    if pieces[0][0] != '@':
                        continue

                    if pieces[0] == '@error':
                        raise Exception(pieces[1])

                    if pieces[0] == '@' + secname:
                        break

                return False

            def _fill_array_flat(arr, parse, col_width):
                n_left = arr.size
                ofs = 0

                while n_left > 0:
                    d = [parse(x) for x in output.readline().split()]
                    n_here = min(n_left, col_width)
                    assert len(d) == n_here, 'expected %d, got %d' % (n_here, len(d))
                    arr.flat[ofs:ofs+n_here] = d
                    n_left -= n_here
                    ofs += n_here

            def _read_variables():
                while True:
                    line = output.readline()
                    if not len(line):
                        break

                    pieces = line.rstrip().split()
                    if not len(pieces):
                        break # variable blocks terminate with blank lines

                    varname = pieces[0]
                    if varname[0] == '@':
                        # If this happens, the section ID gets lost, which is bad.
                        raise Exception('output format error: new section beginning without break')

                    if len(pieces) < 3:
                        # If this happens, *something* is getting lost
                        raise Exception('output format error: unrecognized text in variable block')

                    if pieces[1] == '=': # scalar?
                        yield (varname, pieces[2])
                    elif pieces[1] == '...f': # float array?
                        n_items = int(pieces[2])
                        arr = np.empty(n_items, dtype=np.float)
                        _fill_array_flat(arr, parse_fortran_float, 5)
                        yield (varname, arr)
                    elif pieces[1] == '...i': # int array?
                        n_items = int(pieces[2])
                        arr = np.empty(n_items, dtype=np.int)
                        _fill_array_flat(arr, int, 10)
                        yield (varname, arr)
                    else:
                        raise Exception(r'unrecognized output line: {line:r}')

            _skip_to_section('parameters')
            n_seen = 0

            for varname, value in _read_variables():
                if varname == 'eta1':
                    self.eta1 = parse_fortran_float(value)
                    n_seen += 1
                elif varname == 'nu':
                    self.nu = parse_fortran_float(value)
                    n_seen += 1
                elif varname == 'eta3':
                    self.eta3 = parse_fortran_float(value)
                    n_seen += 1
                elif varname == 'rcutoff':
                    self.r_cutoff = parse_fortran_float(value)
                    n_seen += 1

            if n_seen != 4:
                raise Exception(f'malformed @parameters section: n_seen = {n_seen}')

            _skip_to_section('grid')
            n_seen = 0

            for varname, value in _read_variables():
                if varname == 'ip':
                    self.ip = int(value)
                    n_seen += 1
                elif varname == 'n':
                    self.n = int(value)
                    n_seen += 1
                elif varname == 'm':
                    self.m = int(value)
                    n_seen += 1
                elif varname == 'ind':
                    value = value.reshape((self.m, 6))
                    self.ind = value - 1 # 1-based FORTRAN to 0-based indices
                    n_seen += 1
                elif varname == 'x':
                    self.x = value
                    n_seen += 1
                elif varname == 'y':
                    self.y = value
                    n_seen += 1

            if n_seen != 6:
                raise Exception(f'malformed @grid section: n_seen = {n_seen}')

            def _read_data_block():
                if _skip_to_section('snapshot', eof_ok=True):
                    raise Exception('file %s ended before reaching data block #%d' %
                                    (path, soln_number))

                lam = None
                u = None
                ub = None

                for varname, value in _read_variables():
                    if varname == 'lambda':
                        lam = parse_fortran_float(value)
                    elif varname == 'u':
                        u = value
                    elif varname == 'ub':
                        ub = value

                if lam is None:
                    raise Exception('@snapshot section without lambda value?')

                if u is None:
                    raise Exception('@snapshot section without u value?')

                if ub is None:
                    raise Exception('@snapshot section without ub value?')

                return lam, np.concatenate((u, ub))

            for _ in range(soln_number):
                _read_data_block()

            lam, u = _read_data_block()
            if lam is None:
                raise Exception('file %s ended before reaching data block #%d' %
                                (path, soln_number))

        self.lam = lam
        self.uA = u

        # Set up to quickly look up elements in the FEM array, given the
        # regularities we know about it. The assertions below double-check
        # that the grid has the structure we expect.

        self.ux = np.unique(self.x)[::2] # recall that there are mid-triangle node points
        self.uy = np.unique(self.y)[::2]
        kx = self.ux.size - 1
        ky = self.uy.size - 1

        # UL element in bottom-left corner?
        assert self._info_for_rcolat_slow(self.ux[0] * 1.01,
                                          self.uy[1] * 0.99)[0] == 0

        # LR element in bottom-right corner? (Note: we have uy[0] = 0 so
        # multiplying it by 1.01 doesn't do anything but the test still tests
        # the right thing.)
        assert self._info_for_rcolat_slow(self.ux[-1] * 0.99,
                                          self.uy[0] * 1.01)[0] == 2 * kx - 1

        # LR element in top-right corner?
        assert self._info_for_rcolat_slow(self.ux[-1] * 0.99,
                                          self.uy[-2] * 1.01)[0] == self.m - 1


    def _info_for_rcolat_slow(self, mr, mcolat):
        """Get the "FEM coordinates" for an (r, colat) coordinate, using a slow and
        exhaustive search method. Returns (element number, l0, l1, l2), or
        four Nones if the requested location lies outside of the solution
        grid.

        """
        idx = 0
        adjust_sign = 1
        adjust_ampl = 0
        in_triangle = False

        while True:
            idx += adjust_sign * adjust_ampl
            adjust_sign = -adjust_sign
            adjust_ampl += 1

            if idx >= 0 and idx < self.m:
                gridpoint = self.ind[idx]
                xx = self.x[gridpoint]
                yy = self.y[gridpoint]
                det = (
                    xx[0] * (yy[1] - yy[2]) +
                    xx[1] * (yy[2] - yy[0]) +
                    xx[2] * (yy[0] - yy[1])
                )
                dl1 = ((yy[2] - yy[0]) * (mr - xx[0]) +
                       (xx[0] - xx[2]) * (mcolat - yy[0])) / det
                dl2 = ((yy[0] - yy[1]) * (mr - xx[0]) +
                       (xx[1] - xx[0]) * (mcolat - yy[0])) / det
                dl0 = 1. - dl1 - dl2
                in_triangle = (dl0 >= -1e-6 and dl1 >= -1e-6 and dl2 >= -1e-6)

            if in_triangle or adjust_ampl > 2 * self.m:
                break

        if in_triangle:
            return idx, dl0, dl1, dl2

        return None, None, None, None


    def _info_for_rcolat(self, mr, mcolat):
        """Get the "FEM coordinates" for an (r, colat) coordinate. Returns (element
        number, l0, l1, l2), or four Nones if the requested location lies
        outside of the solution grid.

        This routine uses a relative quick method that exploits the known
        regularities of the FEM grid generated by the KZN code. Some very
        minimal testing indicates that it can be ~500 times faster than the
        "slow" routine.

        """
        # Out of bounds?

        if mr < self.ux[0] or mr > self.ux[-1]:
            return None, None, None, None
        if mcolat < self.uy[0] or mcolat > self.uy[-1]:
            return None, None, None, None

        # OK, we're on the grid. Get the number of the relevant UL triangle.
        # The min/max() calls are needed for the edge cases.

        kx = self.ux.size - 1
        ky = self.uy.size - 1
        ix = min(np.searchsorted(self.ux, mr, side='right') - 1, kx - 1) # in [0, kx-1]
        iy = max(np.searchsorted(self.uy, mcolat, side='left') - 1, 0) # in [0, ky-1]
        idx_ul = 2 * (kx * iy + ix)

        # Re-use the search logic to get dl[012].

        for idx in (idx_ul, idx_ul + 1):
            gridpoint = self.ind[idx]
            xx = self.x[gridpoint]
            yy = self.y[gridpoint]
            det = (
                xx[0] * (yy[1] - yy[2]) +
                xx[1] * (yy[2] - yy[0]) +
                xx[2] * (yy[0] - yy[1])
            )
            dl1 = ((yy[2] - yy[0]) * (mr - xx[0]) +
                   (xx[0] - xx[2]) * (mcolat - yy[0])) / det
            dl2 = ((yy[0] - yy[1]) * (mr - xx[0]) +
                   (xx[1] - xx[0]) * (mcolat - yy[0])) / det
            dl0 = 1. - dl1 - dl2
            in_triangle = (dl0 >= -1e-6 and dl1 >= -1e-6 and dl2 >= -1e-6)

            if in_triangle:
                return idx, dl0, dl1, dl2

        raise Exception('logic error in fast info_for_rcolat routine')


    def _evaluate(self, u, elemnum, dl0, dl1, dl2, default=np.nan):
        "Return a FEM-solved function at given FEM coordinates."

        if elemnum is None:
            return default

        uu = u[self.ind[elemnum]]
        return (uu[0] * (2 * dl0 - 1) * dl0 +
                uu[1] * (2 * dl1 - 1) * dl1 +
                uu[2] * (2 * dl2 - 1) * dl2 +
                uu[3] * 4 * dl0 * dl1 +
                uu[4] * 4 * dl1 * dl2 +
                uu[5] * 4 * dl2 * dl0)


    def _b_field(self, A, elemnum, l0, l1, l2):
        "Return (b_r, b_colat) for the given FEM coordinates."

        # Are we outside the FEM model grid? Various parts of our code become unhappy
        # if the field is truly zero, so in that case, do this:

        if elemnum is None:
            return 0., 1e-8

        # Some prep work. The width/height calculations always work for both
        # UL and LR elements.

        node_indices = self.ind[elemnum]
        x0 = self.x[node_indices[0]]
        y0 = self.y[node_indices[0]]
        elem_x_width = self.x[node_indices[2]] - x0
        elem_y_height = self.y[node_indices[2]] - y0
        u0, u1, u2, u3, u4, u5 = A[node_indices]

        # dA/dr and dA/dcolat:

        k00 = 2 * (u0 + u1 - 2 * u3)
        k22 = 2 * (u2 + u1 - 2 * u4)
        k0 = -u0 - 3 * u1 + 4 * u3
        k2 = -u2 - 3 * u1 + 4 * u4
        k02 = 4 * (u1 + u5 - u4 - u3)

        dA_dl0 = 2 * k00 * l0 + k0 + k02 * l2
        dA_dl2 = 2 * k22 * l2 + k2 + k02 * l0

        if elemnum % 2 == 0:
            # upper-left triangle
            dA_dr = dA_dl2 / elem_x_width
            dA_dcl = -dA_dl0 / elem_y_height

            # help for the final calculation below:
            r = x0 + l2 * elem_x_width
            colat = y0 + (1 - l0) * elem_y_height
        else:
            # lower-right triangle
            dA_dr = -dA_dl0 / elem_x_width
            dA_dcl = dA_dl2 / elem_y_height

            # help for the final calculation below:
            r = x0 + (1 - l0) * elem_x_width
            colat = y0 + l2 * elem_y_height

        # Calculus!

        b_r = dA_dcl / (r**2 * np.sin(colat))
        b_colat = -dA_dr / (r * np.sin(colat))
        return b_r, b_colat


class KZNFieldConfiguration(Configuration):
    __section__ = 'kzn-field'

    model = KZNModelConfiguration
    moment = 3000.
    tilt_deg = 15.
    delta_x = 0.
    delta_y = 0.
    delta_z = 0.

    def to_field(self):
        return KZNField(
            self.model.to_model(),
            self.moment,
            tilt = self.tilt_deg * astutil.D2R,
            delta_x = self.delta_x,
            delta_y = self.delta_y,
            delta_z = self.delta_z,
        )


# Import this late to avoid ordering issues with mutually-dependent modules
from .geometry import TiltedDipoleField

class KZNField(TiltedDipoleField):
    """A tilted magnetic field loaded from the output of the
    Keller/Zwingmann/Neukirch numerical model.

    moment
       The dipole moment, measured in units of [Gauss * R_body**3], where R_body
       is the body's radius. Negative values are OK. Because of the choice of
       length unit, `moment` is the surface field strength by construction.
    tilt
       The angular offset of the dipole axis away from the body's rotation axis,
       in radians. The dipole axis is defined to lie on a body-centric longitude
       of zero.
    delta_x
       The displacement of the dipole center perpendicular to the dipole axis,
       in the plane containing both the dipole axis and the rotational axis
       (i.e., the longitude = 0 plane). Measured in units of the body's
       radius. Positive values move the dipole center towards the magnetic
       latitude of 90°.
    delta_y
       The displacement of the dipole center perpendicular to both the dipole
       axis and the rotational axis (i.e., towards magnetic longitude = 90°).
       Measured in units of the body's radius. Positive values move the dipole
       center towards the magnetic latitude of 90°.
    delta_z
       The displacement of the dipole center along the dipole axis. Measured
       in units of the body's radius. Positive values move the dipole center
       towards the magnetic latitude of 90°.

    """
    def __init__(self, model, moment, tilt=0., delta_x=0., delta_y=0., delta_z=0.):
        super(KZNField, self).__init__(tilt, moment, delta_x=delta_x,
                                       delta_y=delta_y, delta_z=delta_z)
        self.model = model
        self.moment = float(moment)


    @broadcastize(2,(0,0))
    def _br_bth(self, mlat, mr):
        """Compute and return the direction of the magnetic field components (B_r,
        B_lat), given a position in field-centric ("dipole-centric" in
        TiltedDipoleField) coordinates. B_lon is always zero since we're not
        dealing with any of that nonaxisymmetry business.

        """
        mcolat = 0.5 * np.pi - mlat
        b_r = np.empty_like(mlat)
        b_colat = np.empty_like(mr)

        # The model is symmetric around the equator, and so is only computed
        # for colatitudes between 0 and 90. By negating only the radial
        # component, we keep the overall sense of the magnetic field
        # continuous.

        flip = mcolat > 0.5 * np.pi
        mcolat[flip] = np.pi - mcolat[flip]

        for i in range(b_r.size):
            coords = self.model._info_for_rcolat(mr.flat[i], mcolat.flat[i])
            b_r.flat[i], b_colat.flat[i] = self.model._b_field(self.model.uA, *coords)

        # Note that we are *not* applying the r_cutoff cutoff here. By
        # definition, the density is zero there, so the B field orientation
        # really shouldn't matter.

        b_r[flip] *= -1
        b_r *= self.moment
        b_lat = -self.moment * b_colat
        return b_r, b_lat


    @broadcastize(3,0)
    def bmag(self, blat, blon, r):
        """Compute the magnitude of the magnetic field at a set of body-centric
        coordinates.

        """
        mlat, mlon, mr = self._to_dc(blat, blon, r)
        b_r, b_lat = self._br_bth(mlat, mr)
        return np.hypot(b_r, b_lat)


    @broadcastize(3,(0,0,0))
    def bhat(self, pos_blat, pos_blon, pos_r, epsilon=1e-8):
        """Compute the direction of the magnetic field at a set of body-centric
        coordinates, expressed as a set of unit vectors *also in body-centric
        coordinates*.

        """
        # Convert positions to mlat/mlon/r:
        pos_mlat0, pos_mlon0, pos_mr0 = self._to_dc(pos_blat, pos_blon, pos_r)

        # We renormalize the vector to have a tiny magnitude, so we can ignore
        # the r**3. But we need to include M since its sign matters!

        b_r, b_lat = self._br_bth(pos_mlat0, pos_mr0)
        scale = epsilon / np.hypot(b_r, b_lat)
        b_r *= scale
        b_lat *= scale

        # Body-centric coordinates offset in the bhat direction:
        blat1, blon1, br1 = self._from_dc(pos_mlat0 + b_lat,
                                          pos_mlon0,
                                          pos_mr0 + b_r)

        # Unit offset vector. Here again the unit-ization doesn't really make
        # dimensional sense but seems reasonable anyway.
        dlat = blat1 - pos_blat
        dlon = blon1 - pos_blon
        dr = br1 - pos_r
        scale = 1. / np.sqrt(dlat**2 + dlon**2 + dr**2)
        return scale * dlat, scale * dlon, scale * dr


class KZNKWKDistribution(Distribution):
    """A distribution where the overall particle distribution follows that
    prescribed by the KZN model, with constant values for kappa, p, and k.

    """
    __section__ = 'kzn-kwk-distribution'

    model = KZNModelConfiguration
    "The KZNModel object storing the backing model data."

    density_prefactor = 1000.
    "Conversion from model densities to physical values in cm^-3."

    kappa = 3
    "The power-law index of the energetic electrons, such that N(>E) ~ E^(-p)."

    kappa_width = 3
    "The width parameter of the electron kappa distribution."

    pitch_angle_k = 1
    "The power-law index of the pitch angle distribution in sin(theta)."

    _model = None
    _parameter_names = ['n_e', 'kappa', 'width', 'k']


    def _ensure_model(self):
        if self._model is None:
            self._model = self.model.to_model()


    @broadcastize(2,(0,0))
    def _A_term(self, mlat, mr):
        # The model is symmetric around the equator.

        mcolat = 0.5 * np.pi - mlat
        A = np.empty_like(mlat)
        flip = mcolat > 0.5 * np.pi
        mcolat[flip] = np.pi - mcolat[flip]

        for i in range(A.size):
            coords = self._model._info_for_rcolat(mr.flat[i], mcolat.flat[i])
            A.flat[i] = self._model._evaluate(self._model.uA, *coords, default=0.)

        return A


    @broadcastize(3, (0, 0, 0, 0))
    def get_samples(self, mlat, mlon, L, just_ne=False):
        self._ensure_model()
        A = self._A_term(mlat, L)

        # here, sin(colat) = cos(lat), cf eqn. 23 of Neukirch 1993:
        psi = -self._model.eta1 + A + self._model.eta3 * (L * np.cos(mlat))**2
        psi = np.maximum(psi, 0.)
        psi[L >= self._model.r_cutoff] = 0.
        psi **= self._model.nu
        n_e = self.density_prefactor * psi

        if just_ne:
            return (n_e, n_e, n_e, n_e)  # easiest way to make broadcastize happy

        kappa = np.empty(mlat.shape)
        kappa.fill(self.kappa)

        width = np.empty(mlat.shape)
        width.fill(self.kappa_width)

        k = np.empty(mlat.shape)
        k.fill(self.pitch_angle_k)

        return n_e, kappa, width, k
